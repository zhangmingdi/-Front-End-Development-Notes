### eventloop存在的必要性。
+ 为了协调事件，用户交互，脚本，渲染，网络任务等，浏览器必须使用本节中描述的事件循环

### eventloop的流程
+ 任务队列取一个宏任务。
+ 检查微任务队列，执行并清空微任务队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。
+ 宏任务有优先级别，requestAnimationFrame级别最高，鼠标和键盘事件的优先级次高，
+ 进入更新渲染阶段，判断是否需要渲染，这里有一个 rendering opportunity 的概念，也就是说不一定每一轮 event loop 都会对应一次浏览 器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）
### 浏览器的渲染绘制，即绘制一张的机制
+ 浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。
+ 


### 思考setTimeout里面操纵dom没有requestanimationframe的流畅呢
+ 浏览器认为两个Task任务事件间隔过短，没必要发生渲染，导致掉帧。
+ requestanimationframe是浏览器提供一个绘制每一帧之前的一个回调，这样确保了每一帧的dom操作都能绘制出来，所以不出现掉帧情况。
### requestIdleCallback 是浏览器保证每16.66ms绘制一帧后出现的空余时间执行的回调。
+ 如果没有空余时间那么就不执行注册的函数。
+ 如果执行几帧的时间内浏览器都是空闲的，并没有发生任何影响视图的操作这种情况下为什么还是会有 50ms 的 deadline 呢？是因为浏览器为了提前应对一些可能会突发的用户交互操作，比如用户输入文字。如果给的时间太长了，你的任务把主线程卡住了，那么用户的交互就得不到回应了。50ms 可以确保用户在无感知的延迟下得到回应。



### react中的requestIdleCallback的实现
#### react为什么要自己实现requestIdleCallback呢？
+ api兼容性不好。
+ requestIdleCallback 画一帧是20ms，正常需求是16.66ms。
+ 浏览器的requestIdleCallback处于不重要且不紧急的地位，而React渲染内容，并非是不重要且不紧急。


#### react的requestIdleCallback是怎么样计算自己的一帧剩余时间呢